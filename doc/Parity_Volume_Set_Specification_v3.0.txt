
Goal:

Provide a complete solution for the bottom two layers of archiving - redundant data and splitting.  The other layers are best supported by other programs (tar, zip/gzip/7zip, pgp/gpg, etc.).  Provide minimal support for other layers, for ease and integration (e.g., multiple input files).

Expanded goals from Par2:

* support any linear code (Reed-Solomon with Vandermonde matrix or Cauchy, LDPC, random sparse martix)
* support streaming / single-pass recovery
* support parity data inside a ZIP file or other file
* better support splitting files into equal-sized outputs

? support using Par files from other recovery sets for recovery?
? changing filenames after generating parity files?  (Previous version sorted fileids, so changing name meant changing fileid, recovery set id, everything.)

* also: empty directories, more than 2^16 files, UTF8

Use cases:

Usenet:

User wants to send a set of files on Usenet.  They use a Par3 client to generate redundant data in a separate file.  They send the input files and redundant file over Usenet.

The receiver downloads files from Usenet.  Uses Par3 client to verify files and, if any are damaged, recover the damaged files.  

Simple backup:

User wants to backup files.  They use an archiver, like "tar" to create a single file.  They run a Par3 client to create redundant data file or create a new file with both original and redundant data in it.  The backup data and redundancy data is then stored.

If the user sees a problem, they use a Par3 client to verify the backup and, if necessary, repair it.  They then use the archiver program to restore the original files.

Incremental backup:

Same as above, but the user does an incremental backup using an archiver like "tar".  They run a Par3 file to create redundant data for the incremental and original backup.

If the user sees a problem, they use a Par3 client to read the original backup, the incremental backup, and Par3 files generated with each.  The Par3 client verifies the files and, if necessary, repairs them.  The user then uses the archive program to restore the original files.

No-backup redundancy:

User wants to protect files from damage/accidental deletion.  They use a Par3 client to generate redundant data in a file.

If an important file is lost, the Par3 client reads the redundant data file and any existing original files and attempts to recover the important file.  If many other files have changed, recovery may not be possible.

File distribution:

User wants to distribute a set of files together and the package might go out over various transport protocols (website, usenet, etc.).  They use a program like "tar" or "zip" to group the files.  They then use a Par3 client to add redundancy to the single file.

The receiver downloads the file.  They try the archive program to unpack the files.  If the user detects a problem, they can use a Par3 client to repair the file before retrying the archive program.

File streaming:

User wants to transmit file(s) over a one-way connection, with forward error correction.  For example, over UDP or using multicast UDP.  The user include a Par3 library in their program.  The file is converted into Par3 packets, which are sent to the receiver.

The receiving program also includes a Par3 library.  After receiving UDP packets, they are passed to the library, which writes the files.  Then the name of the file is passed back to the receiving program.

NOTE: This use case is file-based.  I don't think we can support stream-based operation, because Par3 clients do recovery on a block-by-block basis.  A user could write the program so that, instead of flushing the stream, closed the current file and sent it to the client and then starting a new file.



